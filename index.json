[
{
	"uri": "http://ekara-platform.github.io/basics/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": " Principles An Ekara environment is a self-contained Docker cluster, spanning one or more nodes (machines). An environment is fully described in a YAML descriptor.\nEkara is built upon two major technologies:\n Ansible, which provides automation for Ekara itself and your project tasks. Docker, which provides containerization with clustering through an orchestrator.  "
},
{
	"uri": "http://ekara-platform.github.io/components/providers/",
	"title": "Providers",
	"tags": [],
	"description": "",
	"content": "\u0026hellip;\n"
},
{
	"uri": "http://ekara-platform.github.io/reference/environment/",
	"title": "Environment",
	"tags": [],
	"description": "",
	"content": " To deploy a fully functional environment, the Ekara engine must first build an internal model of the environment. The model describes every aspect of the environment, including cloud provider(s) to use, machine node(s) to create or software stack(s) to deploy.\nComponents The environment model is built from one or more component(s):\n A component lives in a source repository which is fetched dynamically when necessary, If a component contains an ekara.yaml file, it will be parsed and contribute to the environment model.  Read on about the component model for details.\n Descriptor The Ekara descriptor is a YAML file. By default it is named ekara.yaml and placed at the root level of a source repository:\n\u0026lt;root\u0026gt; |-- ekara.yaml  Read on about the descriptor syntax for details.\n Templating Ekara uses the Go html/template library for its template engine:\n Ekara descriptors are always templated, Arbitrary files in components can also be templated if needed.  Read on about templating for details.\n "
},
{
	"uri": "http://ekara-platform.github.io/components/orchestrators/",
	"title": "Orchestrators",
	"tags": [],
	"description": "",
	"content": "\u0026hellip;\n"
},
{
	"uri": "http://ekara-platform.github.io/reference/",
	"title": "Reference",
	"tags": [],
	"description": "",
	"content": "\u0026hellip;\n"
},
{
	"uri": "http://ekara-platform.github.io/components/",
	"title": "Components",
	"tags": [],
	"description": "",
	"content": "\u0026hellip;\n"
},
{
	"uri": "http://ekara-platform.github.io/components/stacks/",
	"title": "Stacks",
	"tags": [],
	"description": "",
	"content": "\u0026hellip;\n"
},
{
	"uri": "http://ekara-platform.github.io/components/tasks/",
	"title": "Tasks",
	"tags": [],
	"description": "",
	"content": "\u0026hellip;\n"
},
{
	"uri": "http://ekara-platform.github.io/components/providers/aws/",
	"title": "AWS provider",
	"tags": [],
	"description": "",
	"content": "The AWS provider supports the creation and configuraton of Amazon Web-Services EC2 infrastructure to deploy Ekara environments.\nIt can create and configure the following EC2 items:\n Key pairs, Security groups, Placement groups, Instances, Elastic Block Storage (EBS) volumes.  In addition it will also attach, format and mount EBS volumes on instances.\nWhen using the standard Ekara parent, this provider is configured with the ek-aws name.\n Example The following Ekara descriptor provisions 3 small EC2 instances in the \u0026ldquo;eu-west-1\u0026rdquo; region:\nname: myEnvironment ekara: parent: repository: ekara-platform/parent ref: 1.0.0 nodes: app: instances: 3 labels: label1: value1 provider: name: ek-aws params: securityGroups: app: rules: - proto: tcp ports: - 8080 cidr_ip: 0.0.0.0/0 rule_desc: allow all on port 8080 for the application instances: instance_type: \u0026quot;t2.micro\u0026quot; volumes: docker: ebs: volume_size: 10 delete_on_termination: true device_name: /dev/xvdf fs: mount_path: /var/lib/docker  On the infrastructure side, a deploy command with the descriptor above will:\n Ensure that one security group named app for the application exists, opening port 8080 to all IP addresses for TCP. Ensure that 3 instances of type t2.micro exist, based on the default AMI (Ubuntu minimal 18.04 LTS). Ensure that a 10 Go EBS volume named docker exist, formatted with the default filesystem (ext4) and mounted in /var/lib/docker. Ensure that the instances and the volume are tagged with ek_label_label1=value1.  Beyond the items described above, inheriting the Ekara parent will also add some security groups for platform operation.\nReference The following parameters are supported by the AWS provider (in the params element):\n   Name Required Default Value Description     placementGroup False - Parameters that will be passed to the Ansible ec2_placement_group module.   securityGroups False - A map defining the security groups to create. Key: placement group name. Value: parameters passed to the Ansible ec2_group module.   instances True - Parameters that will be passed to the Ansible ec2 module to create instance(s).   volumes False - A map defining the volume(s) to create and attach. Key: volume name. Value: EBS parameters and filesystem parameters.    Placement group The placementGroup parameter correspond to the parameters of the Ansible ec2_placement_group module.\nThe following parameters are set by default and can be overridden:\nname: \u0026quot;\u0026lt;environment_name\u0026gt;_\u0026lt;environment_qualifier\u0026gt;_pg\u0026quot;  The following parameters are forcibly set and cannot be overriden:\nregion: \u0026quot;\u0026lt;provider_region\u0026gt;\u0026quot; state: \u0026quot;present\u0026quot;  Security groups The securityGroups parameter is a map in which:\n The key is the security group name The value correspond to the parameters of the Ansible ec2_group module.  The following parameters are set by default and can be overridden:\nname: \u0026quot;\u0026lt;environment_name\u0026gt;_\u0026lt;environment_qualifier\u0026gt;_\u0026lt;security_group_name\u0026gt;\u0026quot; description: \u0026quot;Security group \u0026lt;security_group_name\u0026gt; for \u0026lt;environment_name\u0026gt;_\u0026lt;environment_qualifier\u0026gt;\u0026quot;  The following parameters are forcibly set and cannot be overriden:\nregion: \u0026quot;\u0026lt;provider_region\u0026gt;\u0026quot; state: \u0026quot;present\u0026quot;  Instances The instances parameter correspond to the parameters of the Ansible ec2 module.\nThe following parameters are set by default and can be overridden:\ninstance_tags: Name: \u0026quot;\u0026lt;environment_name\u0026gt; (\u0026lt;environment_qualifier\u0026gt;) - \u0026lt;nodeset_name\u0026gt;\u0026quot;  The following parameters are forcibly set and cannot be overriden:\nkey_name: \u0026quot;ek_\u0026lt;environment_name\u0026gt;_\u0026lt;environment_qualifier\u0026gt;\u0026quot;, region: \u0026quot;\u0026lt;provider_region\u0026gt;\u0026quot;, wait: true, exact_count: \u0026lt;nodeset_instance_count\u0026gt;, count_tag: ek_nodeset_id: \u0026quot;\u0026lt;environment_name\u0026gt;_\u0026lt;environment_qualifier\u0026gt;_\u0026lt;nodeset_name\u0026gt;\u0026quot; instance_tags: ek_env_id: \u0026quot;\u0026lt;environment_name\u0026gt;_\u0026lt;environment_qualifier\u0026gt;\u0026quot;, ek_nodeset_id: \u0026quot;\u0026lt;environment_name\u0026gt;_\u0026lt;environment_qualifier\u0026gt;_\u0026lt;nodeset_name\u0026gt;\u0026quot;, ek_nodeset_name: \u0026quot;\u0026lt;nodeset_name\u0026gt;\u0026quot;  If necessary, the name of the placement group is automatically injected into the instance settings as:\nplacement_group: \u0026quot;\u0026lt;placement_group_name\u0026gt;\u0026quot;  If necessary, the identifiers of the security group(s) are injected as:\ngroup_id: [ \u0026quot;\u0026lt;sg1_id\u0026gt;\u0026quot;, \u0026quot;\u0026lt;sg2_id\u0026gt;\u0026quot;, ... ]  If necessary, the node set labels are injected as:\ninstance_tags: ek_label_\u0026lt;label_name\u0026gt;: \u0026quot;\u0026lt;label_value\u0026gt;\u0026quot; ...  Volumes Elements under the volumes parameter correspond to a map in which:\n The key is the volume name The value is a map containing the following elements:  ebs which correspond to the parameters of the Ansible ec2_vol module. fs which correspond to the parameters of the ekara-platform/ansible-role-filesystem role.   The following parameters are set by default and can be overridden:\nebs: volume_type: \u0026quot;gp2\u0026quot;  The following parameters are forcibly set and cannot be overriden:\nebs: state: \u0026quot;present\u0026quot; "
},
{
	"uri": "http://ekara-platform.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ekara-platform.github.io/reference/cli/",
	"title": "Command-line interface (CLI)",
	"tags": [],
	"description": "",
	"content": " The Ekara command-line interface (CLI) can be used to create new environments or interact with existing ones.\nCommands The CLI tool accepts various commands. Learn about them here.\nCommon options The following options are supported by all commands.\nProxy options:\n --http-proxy \u0026lt;url\u0026gt;: HTTP proxy URL (defaults to the http_proxy environment variable if defined). --https-proxy \u0026lt;url\u0026gt;: HTTPS proxy URL (defaults to the https_proxy environment variable if defined). --no-proxy \u0026lt;list\u0026gt;: Comma-separated list of proxy exclusions (defaults to the no_proxy environment variable if defined).  Docker options Commands that interact directly with a Docker daemon (like deploy) accept the following options:\n --docker-cert \u0026lt;path\u0026gt;: Location of the docker certificates (defaults to the DOCKER_CERT_PATH environment variable if defined). !! TODO !! --docker-host \u0026lt;url\u0026gt;: URL of the docker host (defaults to the DOCKER_HOST environment variable if defined). !! TODO !! --installer-tag \u0026lt;tag\u0026gt;: allow to specify the tag of the installer Docker image to be used (defaults to latest otherwise). !! TODO !!  Repository URL (with tags and branches) Some commands take a repository URL as argument. This section details the syntax of this argument. The most basic form is a complete HTTP(S) repository URL:\n# Using the master branch $ ekara deploy http://github.com/ekara-platform/demo  To use a given tag or a branch of your repository you need to postfix the raw repository URI with @tag_name or @branch_name.\n# Using a given tag of your repository $ ekara deploy http://github.com/ekara-platform/demo@tag_name # Using a given branch of your repository $ ekara deploy http://github.com/ekara-platform/demo@branch_name  If you have the same name between a tag and a branch, the Ekara installation process will look first for the tag and a then for the branch.\n "
},
{
	"uri": "http://ekara-platform.github.io/reference/cli/commands/",
	"title": "Commands",
	"tags": [],
	"description": "",
	"content": " List of available commands:\n check: validates an existing environment descriptor. deploy deploys a new environment (validate descriptor, create infrastructure, install OS + orchestrator and deploy stacks). dump: dumps the effective environment descriptor (fully aggregated and templated). help: displays a list of the available commands or display help on a particular command. version: displays the Ekara version.  You can use the -h or --help option on any command to get further help.\n Check This command fetch and validates an environment model:\n$ ekara check \u0026lt;repository-url\u0026gt; [options]  Arguments:\n repository-url: the URL of the repository where the main environment descriptor is located.  Options:\n -u --user \u0026lt;user-name\u0026gt;: the user to use for authenticated repositories. -p --password \u0026lt;user-password\u0026gt;: the password to use for authenticated repositories. -v --vars \u0026lt;vars-file\u0026gt;: location of the external variables file that will be used for templating.  This is a command requiring a Docker daemon. It also accepts Docker options.\n Deploy This command deploys a new environment or updates it if it already exists. It goes through the following steps:\n Validation of the environment descriptor (same as the check command), Creation of the infrastructure, Installation and configuration of the OS + orchestrator, Deploy the software stacks.\n$ ekara deploy \u0026lt;repository-url\u0026gt; [options]   Arguments:\n repository-url: the URL of the repository where the main environment descriptor is located.  Main options:\n -u --user \u0026lt;user-name\u0026gt;: the user to use for authenticated repositories. -p --password \u0026lt;user-password\u0026gt;: the password to use for authenticated repositories. -v --vars \u0026lt;vars-file\u0026gt;: location of the external variables file that will be used for templating. -l --logs: turn on the installer logs on the console (otherwise logs are only written in a file named installer.log) --public-key \u0026lt;path\u0026gt; Path to the public key to be used for remote node access (if none given a key will be generated and written in output directory). --private-key \u0026lt;path\u0026gt; Path to the private key key to be used for remote node access (if none given a key will be generated and written in output directory).  Example with parameter file and logs:\n$ ekara deploy http://github.com/ekara-platform/demo -v vars.yaml -l  Two subcommands are available, taking the same arguments and options:\n create-only: this will stop the process at the end of step 2 (creation of the infrastructure). install-only: this will stop the process at the end of step 3 (installation of the OS + orchestrator).  Dump This command dumps the effective environment descriptor (fully aggregated and templated):\n$ ekara dump \u0026lt;repository-url\u0026gt; [flags]  Arguments:\n repository-url: the URL of the repository where the main environment descriptor is located.  Main options:\n -u --user \u0026lt;user-name\u0026gt;: the user to use for authenticated repositories. -p --password \u0026lt;user-password\u0026gt;: the password to use for authenticated repositories. -v --vars \u0026lt;vars-file\u0026gt;: location of the external variables file that will be used for templating.  This is a command requiring a Docker daemon. It also accepts Docker options.\n Help This command displays a list of the available commands:\n$ ekara help [command]  Arguments:\n command: if specified, displays help on this particular command.  Version This command displays the versions of the command-line executable:\n$ ekara version  The command-line executable always use the latest tag of the installer Docker image. You can force a tag with the --installer-tag option.\n "
},
{
	"uri": "http://ekara-platform.github.io/reference/environment/components/",
	"title": "Component model",
	"tags": [],
	"description": "",
	"content": " Before doing any work, the Ekara engine must build a model of the environment that is worked on. This model is aggregated from multiple descriptors, located in components that must be discovered, fetched et parsed. A component:\n Lives in a source repository which is fetched dynamically when necessary. Can optionally contain a descriptor file, named ekara.yaml by default.  The first component to be fetched is either specified in the command-line (in the case of a new environment) or already known (in the case of an existing environment).\n Example Consider the following components:\n The starting point of component discovery is called the main component (1). The main component declares a parent component (2). The parent itself declares its own parent component, forming an inheritance chain (3). At each level in the inheritance chain, additional components can also be referenced (1b, 2b, 3b).  Typically, parent components are used to regroup parameters common to set of environments. For instance, multi-level parents can be used to regroup settings in organizational layers.\n Aggregation After all components have been discovered, the effective model aggregation occurs:\n Components referenced by the top-level parent (3b) are parsed in their declaration order, defining the initial model. Then the top-level parent (3) is merged. Then components referenced by the intermediate parent (2b) are merged. Then the intermediate parent 2 is merged. Then components referenced by the main component (1b) are merged. Then the main component (1) is merged.  Each step can extend or override values defined in previous ones.\nDeclaration To declare a component (parent or referenced), use the following attributes:\n A repository attribute denoting the source repository holding component code. A ref attribute denoting the branch, tag or commit of the component to fetch. An auth attribute only required when authentication is required to access the source repository.  Repository The repository attribute allows to specify the location of a component:\nekara: components: aPublicComponent: repository: https://github.com/myOrganisation/my-public-rep  Currently git is the only source control management system supported for repositories.\n Ref The ref attibutes identifies the branch, tag or commit to fetch:\ncomponents: aPublicComponent: repository: https://github.com/myOrganisation/my-public-rep ref: aGivenBranch  When a ref attribute is specified, Ekara will:\n Try to find a matching tag. If no tag is found, it will try to find a matching branch. If no branch is found, it will try to find a matching commit.  The default value for ref is master.\n Authentication The auth attribute specifies the authentication information required to connect to a private repository.\nExample:\nekara: components: aPrivateComponent: repository: https://github.com/myOrganisation/my-private-rep auth: method: basic user: yourUserName password: yourUserPassword  Currently basic is the only authentication method supported.\n You can externalize data like credentials from descriptors by using templating.\n "
},
{
	"uri": "http://ekara-platform.github.io/reference/environment/descriptor/",
	"title": "Descriptor syntax",
	"tags": [],
	"description": "",
	"content": " The Ekara descriptor is a YAML document consisting of the following top-level sections:\n The general properties, defining basic information of the environment. The ekara section, defining the environment base and components. The vars section, declaring variables that can be used throughout all descriptors and templated files. The templates section, declaring files relative to the descriptor that needs templating. The providers section, declaring infrastructure providers capable of creating nodes. The orchestrator section, declaring the Docker orchestrator to use. The nodes section, declaring the physical nodes of the environment. The stacks section, declaring the Docker stacks to deploy on the cluster. The tasks section, declaring playbooks that can be executed on a particular event.  General properties The following properties define the basic information of the environment:\n# Name of the environment (mandatory) name: myEnvironment # Optional qualifier of the environment (like dev, test, prod, ...) qualifier: dev # Optional description of the environment descriptor: This is my awesome ekara environment.  Ekara The ekara section controls the Ekara platform settings:\nekara: # The base location for short-form repositories base: https://github.com # Parent component to inherit from parent: repository: ekara-platform/parent ref: v1 # Additional components to be imported components: myComponent: repository: my-organization/my-component ref: v2  Read more about how components are discovered and parsed.\n Base The base location is used to resolve short repository names for the descriptor only:\nekara: base: https://a.given.base.com parent: repository: my-organization/parent components: myComponent: repository: my-organization/my-component  The declaration above will result in the following resolved URLs:\n The parent: https://a.given.base.com/my-organization/distribution The component: https://a.given.base.com/my-organization/my-component  When no base is specified, Ekara will use https://github.com as default.\n Parent The parent is a component from which everything will be inherited in the environment. A parent can also have a parent itself.\nComponents Additional components can be declared in the components section but will only be fetched and imported upon effective use in the descriptor.\nVariables An environment descriptor can define variables, which can then be used in templating:\nvars: var1_key: descriptor_var1_values var2_key: descriptor_var2_values  A variable can only be used in templating if it already has been declared in:\n The current descriptor, A parent descriptor above, A component referenced from a parent descritor above, The command-line given parameters file.  Variable precedence follow the component precedence rules.\n Templates Although the Ekara descriptor itself is always templated, if you want to template other files of the component you must declare them in the following section:\ntemplates: - docker-compose.yaml - config/**/*.conf  Template paths must be relative to the descriptor file (i.e. the component root). Glob patterns can be used to match multiple files in a single expression.\nRead more about templating for more details.\n Providers The providers section declares the cloud providers that can be used for creating node sets:\nproviders: ek-aws: # Name of the provider component component: ek-aws # Provider parameters applicable to all node sets (unless overridden) params: region: eu-west-1  Orchestrator The orchestrator section declares the container orchestrator that will be installed:\norchestrator: # Name of the orchestrator component component: ek-swarm # Orchestrator parameters applicable to all node sets params: someParam: someValue # Docker parameters applicable to all node sets docker: someParam: someValue  While the params section is used to configure the orchestrator, the docker section is used for Docker itself.\n Nodes The nodes section declares the machines on which the environment will run, grouped by node sets:\nnodes: managers: # Number of identical nodes in this node set instances: 3 # Node labels for selection purposes labels: label1: value1 label2: value2 # Provider for node provisioning provider: # Name of a provider declared in the providers section name: ek-aws # Provider parameters for this node set (overriding general provider parameters) params: someAwsParam: someValue orchestrator: # Orchestrator parameters for this node set (overriding general orchestrator parameters) params: someSwarmParam: someValue # Docker parameters for this node set (overriding general docker parameters) docker: someDockerParam: someValue  A special node set named * can be declared for parameters common to all nodesets.\n Stacks The stacks section declares the software stacks that will be deployed in the environment:\nstacks: myStack: # Component containing the software stack component: some-stack  The component referenced must contain:\n A file recognized by the orchestrator to be a software stack (like a docker-compose.yaml file for Docker Swarm), And/or a deploy.yaml playbook for custom deployment.  Tasks The tasks section declares the tasks that can be executed in the environment:\ntasks: myTask: # The component containing the task component: myComponent # The location of the playbook to execute task: task1.yaml # The parameters to be passed to the playbook params: param1: value1 # If specified the task will be executed automatically according to the specified schedule cron: 0 * * * *  "
},
{
	"uri": "http://ekara-platform.github.io/",
	"title": "Ekara",
	"tags": [],
	"description": "",
	"content": " Ekara platform Ekara creates and maintain reproducible Docker environments, from scratch. An Ekara environment is:\n Self-contained and autonomous. Manageable through a simple REST API.\n Deployable on any supported provider whether in the cloud or on premise.   Download and install You interact with Ekara through its client binary. To download it:\n Go to https://github.com/ekara-platform/cli/releases Download the binary corresponding to your operating system Put the downloaded binary in your favorite location and rename it to \u0026ldquo;ekara\u0026rdquo;. Add the directory containing the executable to your PATH environment variable.  You should now be able to run ekara version from the anywhere in the command-line.\n "
},
{
	"uri": "http://ekara-platform.github.io/components/stacks/aws/",
	"title": "Ekara core",
	"tags": [],
	"description": "",
	"content": "The Ekara core stack contains the essential components to allows the Ekara platform to work.\nThe following components are installed:\n Hashicorp Consul which provides distributed servicesfor the platform: persistence, service discovery, coordination, \u0026hellip; The Ekara API which allows to manage an environment from outside. Other Ekara services like auto-deploy.  When using the standard Ekara parent, this stack is always deployed on all manager nodes.\n Example The following Ekara descriptor provisions 3 small EC2 instances in the \u0026ldquo;eu-west-1\u0026rdquo; region:\nname: myEnvironment ekara: parent: repository: ekara-platform/parent ref: 1.0.0 nodes: app: instances: 3 provider: name: ek-aws params: instances: instance_type: \u0026quot;t2.micro\u0026quot;  After creating a minimal infrastructure on AWS for details) and deploying a Docker Swarm cluster on it,a deploy command with the descriptor above will deploy the core stack on all manager nodes.\nReference No parameters are accepted.\n"
},
{
	"uri": "http://ekara-platform.github.io/reference/cli/variables/",
	"title": "External variables",
	"tags": [],
	"description": "",
	"content": " CLI commands working with a descriptor accept the -p, --param, which specifies the YAML to use as a source for external variables. Those variables can then be used in templating. Templating is always applied to descriptors and can be optionally applied to arbitrary files in components.\nVariables Variables can come from:\n An external source like the file described here, A vars section in that can be specified in each descriptor file.  File format The only requirement is that the file must be a valid YAML file. Data can be structured as required.\nConsider this trivial example:\napp: visualizer: port: 8080  And this descriptor:\nname: myEnv providers: ek-aws: params: securityGroups: app: rules: - proto: tcp ports: - {{ .Vars.app.visualizer.port }} cidr_ip: 0.0.0.0/0 rule_desc: allow all on port {{ .Vars.app.visualizer.port }} for the swarm visualizer # ...  The following effective descriptor will be produced:\nWill produce :\nname: myEnv providers: ek-aws: params: securityGroups: app: rules: - proto: tcp ports: - 8080 cidr_ip: 0.0.0.0/0 rule_desc: allow all on port 8080 for the swarm visualizer # ...  "
},
{
	"uri": "http://ekara-platform.github.io/components/orchestrators/docker-swarm/",
	"title": "Swarm orchestrator",
	"tags": [],
	"description": "",
	"content": "The Swarm orchestrator supports the installation and configuration of a Docker Swarm cluster on an Ekara environment infrastructure.\nWhen using the standard Ekara parent, this orchestrator is enabled and configured with the ek-swarm name.\n Example The following Ekara descriptor will create 3 small EC2 instances in the \u0026ldquo;eu-west-1\u0026rdquo; region and setup Docker Swarm on it:\nname: myEnvironment ekara: parent: repository: ekara-platform/parent ref: 1.0.0 nodes: app: instances: 3 provider: name: ek-aws params: instances: instance_type: \u0026quot;t2.micro\u0026quot;  After creating a minimal infrastructure on AWS (see AWS provider reference for details), a deploy command with the descriptor above will:\n Ensure that the operating system is fully installed with necessary packages on all nodes. Ensure that Docker is installed in the latest version on all nodes. Ensure a Swarm cluster exists spanning all nodes. Ensure that the Swarm managers/workers are properly affected according to node role.  Reference Docker parameters The following Docker parameters are supported by the provider (in the params element):\n   Name Required Default Value Description     daemon False - Everything under this parameter will be written as JSON daemon configuration.   tls False - Options for TLS configuration of the daemon.   remap False True If true the containers will be isolated with a user namepsace.    Daemon configuration The elements under daemon parameter will be written as the Docker JSON configuration file.\nThe default daemon configuration is:\ndaemon: log-driver: json-file log-opts: max-size: \u0026quot;20m\u0026quot; max-file: \u0026quot;3\u0026quot; userland-proxy: true live-restore: false hosts: - \u0026quot;unix:///var/run/docker.sock\u0026quot; - \u0026quot;tcp://0.0.0.0:2376\u0026quot;  Any value can be overridden.\nTLS configuration groups The tls parameter controls the TLS configuration of the Docker daemon. This is the default configuration with explanations as comments:\ntls: # If true TLS will be required, if false Docker daemon will accept unsecured connections. enabled: true # The path of the CA certificate nodes cacert: \u0026quot;/etc/docker/certs/ca.pem\u0026quot; # The path of the certificate nodes cert: \u0026quot;/etc/docker/certs/cert.pem\u0026quot; # The path of the key nodes key: \u0026quot;/etc/docker/certs/key.pem\u0026quot;  Remap If the remap parameter is set to True (its default value), containers will be isolated from the host using a a user namespace. Enabling this improves security as it prevents UIDs in containers to have any privilege on the host.\n"
},
{
	"uri": "http://ekara-platform.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ekara-platform.github.io/reference/environment/templating/",
	"title": "Templating",
	"tags": [],
	"description": "",
	"content": " Templating is a data-driven mechanism to generate a particular textual output. In Ekara, templating is done automatically:\n Descriptors are always templated, Arbitrary files in components can also be templated if needed.  Ekara uses the Go text/template library as its template engine.\n Basics Templates are executed by applying them to a data structure, provided by Ekara. The data structure defines the following top-level elements:\n Vars, which contains user-defined variables. Model, which contains functions to access a read-only view of the environment model. Runtime, which contains functions to access a read-only view of execution data.  The input text for a template is UTF-8-encoded text in any format. Actions (data evaluations or control structure) are delimited by {{ and }}:\nname: {{ .Vars.myProject.name }}  All text outside those delimiters is copied to the output unchanged.\nExecution of the template walks the structure and sets the cursor, represented by a period . and called \u0026ldquo;dot\u0026rdquo;, to the value at the current location in the structure as execution proceeds. For instance, in loops the dot become a reference to the current item. It can also be set explictly using the with action.\n Variables The .Vars section of the structure contains the accumulation of:\n The external variables (for instance given by a var file from the command-line). The descriptor variables, given by the vars section.  Because the .Vars section is populated sequentially during the environment model aggregation, a particular descriptor can only be templated by:\n The external variables, The variables declared up in its inheritance chain:  In the parent(s) In the components referenced from the parent(s)  Its own variables.  Meta-model The .Model section of the structure contains functions to access a read-only view of the environment model currently worked on. It can be think of as the meta-model of the Ekara engine.\nThe meta-model exported interfaces are documented at https://godoc.org/github.com/ekara-platform/model/tmodel.\n Accessing the meta-model during the construction of the model itself is limited. Only .Model.Name, .Model.Qualifier and .Model.QualifiedName are accessible when templating descriptors.\n Templating additional files The descriptor is always templated but other files of a component can templated too. You can declare files to be templates like this:\ntemplates: - docker-compose.yaml - config/**/*.cfg  Template paths must be relative to the descriptor file (i.e. the component root). Glob patterns can be used to match multiple files in a single expression.\nWhen templating additional files, all variables are available and meta-model functions can be used without restriction.\n Example Consider the following \u0026ldquo;variable file\u0026rdquo; passed from the command-line:\n# Parameters file from the CLI app: a: cli_value  A parent defining the following variables:\n# Variables in the parent descriptor vars: app: b: parent_{{ .Vars.app.a }} c: parent_value  And a main descriptor defining the following variables:\n# Variables in the main descriptor name: myEnv qualifier: dev vars: app: d: main_{{ .Model.QualifiedName }}_{{ .Vars.app.b }}  Final values in the main descriptor will be:\n {{ .Vars.app.a }} will evaluate to cli_value\n {{ .Vars.app.b }} will evaluate to parent_cli_value\n {{ .Vars.app.c }} will evaluate to parent_value {{ .Vars.app.d }} will evaluate to main_myEnv_qualifier_parent_cli_value\n  "
}]